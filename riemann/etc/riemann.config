; -*- mode: clojure; -*-
; vim: filetype=clojure
(logging/init {:file "/var/log/riemann.log"})

(def victorops-api-key "TODO") ; TODO 

(defn notify [routing-key]
  (let [vo (victorops victorops-api-key routing-key)]
    (changed-state {:init "ok"}
                   (where (state "info") (:info vo))
                   (where (state "warning") (:warning vo))
                   (where (state "critical") (:critical vo))
                   (where (state "ok") (:recovery vo)))))
;

; borrowed from https://kartar.net/2016/04/managing-maintenance-with-riemann/
(defn maintenance-mode? [event]
  (->> (list 'and
             '(= :type "maintenance-mode")
             (list '= :service (-> event
                                   :service
                                   (clojure.string/split #" " 2)
                                   first)))
       (riemann.index/search (:index @core))
       first
       :state
       (= "active")))

(def tell-team
  (changed-state {:init "ok"}
                 (where (not (maintenance-mode? event))
                        (notify "architecture")))) ; TODO

(def tell-other-team
  (changed-state {:init "ok"}
                 (where (not (maintenance-mode? event))
                        (notify "other-architecture")))) ; TODO

; overriding the graphite-server decode-graphite-line function. 
; It is responsible for parsing a line. Per definition graphite
; can only carry numeric metrics. This implementation is more
; flexible and also allows other types
(binding [*ns* (find-ns 'riemann.transport.graphite)] 
  (eval '(def decode-graphite-line
           (fn [line]
             (let [[service metric timestamp & garbage] (split line #"\s+")]
               ; Validate format
               (cond garbage
                     (throw+ "too many fields")
                     
                     (= "" service)
                     (throw+ "blank line")
                     
                     (not metric)
                     (throw+ "no metric")
                     
                     (not timestamp)
                     (throw+ "no timestamp")
                     
                     (re-find #"(?i)nan" metric)
                     (throw+ "NaN metric"))
    ; Parse numbers
    (let [metric (try (Double. metric)
                      (catch NumberFormatException e
                        ; still proceed although the metric could not be transformed into a numeric value
                        metric ))
          timestamp (try (Long. timestamp)
                         (catch NumberFormatException e
                           (throw+ "invalid timestamp")))
          [host service-name metric-name] (clojure.string/split service #"\." 3)]
      ; Construct event
      (->Event host 
               (str service-name " " metric-name)
               nil
               nil
               metric
               nil
               timestamp
               nil)))))))

; borrowed from https://github.com/pyr/riemann-extra/blob/master/src/org/spootnik/riemann/thresholds.clj,
; until team makes available library in classpath
; start
(defn find-specific-threshold
  [{:keys [host tags]}
   {:keys [match-host match-tag match-default] :as threshold}]
  (cond
   match-tag     (and ((set tags) match-tag) threshold)
   match-host    (and (= match-host host) threshold)
   match-default threshold))

(defn match-threshold
  [{:keys [service]} [pattern payload]]
  (when (re-matches pattern service)
    payload))

(defn find-threshold
  [thresholds re-patterns event]
  (if-let [thresholds (or (get thresholds (:service event))
                          (some (partial match-threshold event) re-patterns))]
    (if (sequential? thresholds)
      (some (partial find-specific-threshold event) thresholds)
      thresholds)))

(defn threshold-check
  "Given a list of standard or inverted thresholds, yield
   a function that will adapt an inputs state.
   The output function does not process events with no metrics"
  [thresholds]
  (let [re-patterns (filter (complement (comp string? key)) thresholds)]
    (fn [{:keys [metric tags] :as event}]
      (try
        (if-let [{:keys [warning critical invert exact add-tags]}
                 (if metric (find-threshold thresholds re-patterns event))]
          (assoc event
            :tags (clojure.set/union (set tags) (set add-tags))
            :state
            (cond
             (nil? metric) "unknown"
             (and exact (not= (double metric) (double exact))) "critical"
             (and exact (= (double metric) (double exact)))    "ok"
             (and critical ((if invert <= >) metric critical)) "critical"
             (and warning ((if invert <= >) metric warning)) "warning"
             :else "ok"))
          event)
        (catch Exception e
          (error e "threshold-check failed for " event))))))
; end

; Listen on the local interface over TCP (5555), UDP (5555), and websockets
; (5556)
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host})
  (graphite-server  {:host host}))

(periodically-expire 10)

(def devnull (fn [& _]))

; TODO optimize, make better change detection
(defn delta-over-time [n & children]
  (moving-time-window n
                      #(when (> (count %) 1)
                         (let [f (first %) l (last %)
                               fval (:metric f)
                               lval (:metric l)]
                           (when (and (number? fval) (number? lval))
                             (call-rescue (assoc l
                                                 :metric (- lval fval)
                                                 :service (str (:service l) "_dt"))
                                          children))))))

(defn profiler [index]
  (splitp re-find service
          ; Aggregate rate of samples taken
          #"profiler rate" (coalesce
                               ; Total sample rate
                               (smap folds/sum
                                     (with :host nil
                                           index))

                               ; Distinct number of hosts
                               (smap folds/count
                                     (adjust [:service clojure.string/replace "rate" "hosts"]
                                             (with :host nil
                                               index))))

          ; Flatten function times across hosts, updating every 60s.
          #"profiler fn"
          (pipe - (by :service
                      (coalesce 60
                                (smap folds/sum
                                      (with {:host nil :ttl 120} -))))
                ; And index the top 10.
                (top 10 :metric
                     index
                     (with :state "expired" index)))))

; appender stream
(def appender-metrics-thresholds {"someWebApp ch.qos.logback.core.Appender.error count" {:critical 15}})

(defn appender-metrics [index]
  (let [index (with :state "ok"
                index)]
        (splitp re-find service
                #"debug count|error count|info count|trace count|warn count" (by [:host :service]
                                                                                 (delta-over-time 60 index))
                
                #"all count"
                ; Sum up counters for all hosts
                (by [:service]
                    (coalesce 4
                              (smap folds/sum
                                    (with {:host nil}
                                      (adjust [:service clojure.string/replace #"$" "_sum"]
                                              ; Calcuate delta every N seconds
                                              (delta-over-time 60 (smap (threshold-check appender-metrics-thresholds)
                                                                        index)))))))
                devnull)))

; servlet stream
(def servlet-metrics-thresholds {"someWebApp org.eclipse.jetty.servlet.ServletHandler.5xx-responses count_dt" {:warning 1 :critical 5}})

(defn servlet-metrics [index]
  (let [index (smap (threshold-check servlet-metrics-thresholds)
                    index)]
    (splitp re-find service
            #"\.requests count" (coalesce (smap folds/sum
                                                (adjust [:service clojure.string/replace #"$" "_sum"]
                                                        (with :host nil
                                                          index))))
            #"xx-responses count" (by [:host :service]
                                      (delta-over-time 60 
                                                       index))
            #".*p.*" index
          devnull)))

; jvm memory stream
(def memory-metrics-thresholds {"someWebApp memory.heap.used" {:warning 50.0 :critical 90.0}})

(defn memory-metrics [index]
  (splitp re-find service
          #".*heap\.used$" (scale (/ 1 1024 1024)
                                  (smap (threshold-check memory-metrics-thresholds)
                                        index))
          devnull))

; jvm thread stream
(def thread-metrics-thresholds {"someWebApp thread.count" {:warning 100 :critical 150}})

(defn thread-metrics [index]
  (splitp re-find service
          #"thread.count|thread.blocked.count|thread.timed_waiting.count|thread.waiting.count" (smap (threshold-check thread-metrics-thresholds)
                                                                                                     index)
          devnull))

; jvm gc stream
(def gc-metrics-thresholds {})

(defn gc-metrics [index]
  index)

; hystrix stream
(def hystrix-metrics-thresholds {"someWebApp hystrix.HystrixCommand.RemoteRequestCommand.isCircuitBreakerOpen" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countTimeout_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countFailure_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countExceptionsThrown_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countThreadPoolRejected_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countShortCircuited_dt" {:critical 0.1}})

(defn hystrix-metrics [index]
  (splitp re-find service
          #"isCircuitBreakerOpen" (adjust (fn [{:keys [service metric] :as e}]
                                            (assoc e :metric (if (= "true" metric)
                                                               1.0
                                                               0.0)))
                                          (smap (threshold-check hystrix-metrics-thresholds)
                                                tell-other-team
                                                index))
          #"countSuccess" (by [:host :service]
                              (delta-over-time 60 (with :state "ok"
                                                    index)))
          #"countTimeout|countFailure|countExceptionsThrown|countThreadPoolRejected|countShortCircuited" (by [:host :service]
                                                                                                             (delta-over-time 60 (smap (threshold-check hystrix-metrics-thresholds)
                                                                                                                                       tell-team
                                                                                                                                       index)))
          #"latencyTotal_percentile" (by [:service] (coalesce
                                                      (smap folds/maximum
                                                            (with :host nil
                                                              index))))
          devnull))

(let [index (default {:ttl 60} (index))]
  (streams
    (where (and
             (not (expired? event))
             (= "maintenance-mode" (:type event)))
           index)
    (where (not (service nil))
      (splitp re-find service
              #"-health$" (by [:service]
                              (changed-state {:init "ok"}
                                             (adjust [:state #(if (= "expired")
                                                                "critical"
                                                                %)]
                                                     tell-team
                                                     index)))
              #"^someWebApp" (throttle 1 15
                                       (with {:service "someWebApp-health"
                                              :metric 1
                                              :ttl 30 
                                              :host nil
                                              :tags nil 
                                              :state "ok"}
                                         reinject
                                         index))
              devnull))
    (where (not (or
                  (service nil)
                  (expired? event)))
           (splitp re-find service
                   #"^someWebApp profiler" (profiler index)
                   #"^someWebApp ch.qos.logback.core.Appender" (appender-metrics index)
                   #"^someWebApp org.eclipse.jetty.servlet.ServletHandler" (servlet-metrics index)
                   #"^someWebApp memory" (memory-metrics index)
                   #"^someWebApp thread" (thread-metrics index)
                   #"^someWebApp gc" (gc-metrics index)
                   #"^someWebApp hystrix" (hystrix-metrics index)
                   #"^riemann" devnull 
                   ;#"^fridge" (notify index)
                   devnull))))
