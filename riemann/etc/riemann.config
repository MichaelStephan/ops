; -*- mode: clojure; -*-
; vim: filetype=clojure
(logging/init {:file "/var/log/riemann.log"})

(def victorops-api-key "TODO") ; TODO 
(def victorops-routing-key "architecture") 

; overriding the graphite-server decode-graphite-line function. 
; It is responsible for parsing a line. Per definition graphite
; can only carry numeric metrics. This implementation is more
; flexible and also allows other types
(binding [*ns* (find-ns 'riemann.transport.graphite)] 
  (eval '(def decode-graphite-line
           (fn [line]
             (let [[service metric timestamp & garbage] (split line #"\s+")]
               ; Validate format
               (cond garbage
                     (throw+ "too many fields")
                     
                     (= "" service)
                     (throw+ "blank line")
                     
                     (not metric)
                     (throw+ "no metric")
                     
                     (not timestamp)
                     (throw+ "no timestamp")
                     
                     (re-find #"(?i)nan" metric)
                     (throw+ "NaN metric"))
    ; Parse numbers
    (let [metric (try (Double. metric)
                      (catch NumberFormatException e
                        ; still proceed although the metric could not be transformed into a numeric value
                        metric ))
          timestamp (try (Long. timestamp)
                         (catch NumberFormatException e
                           (throw+ "invalid timestamp")))
          [host service-name metric-name] (clojure.string/split service #"\." 3)]
      ; Construct event
      (->Event host 
               (str service-name " " metric-name)
               nil
               nil
               metric
               nil
               timestamp
               nil)))))))

; borrowed from https://github.com/pyr/riemann-extra/blob/master/src/org/spootnik/riemann/thresholds.clj
; start
(defn find-specific-threshold
  [{:keys [host tags]}
   {:keys [match-host match-tag match-default] :as threshold}]
  (cond
   match-tag     (and ((set tags) match-tag) threshold)
   match-host    (and (= match-host host) threshold)
   match-default threshold))

(defn match-threshold
  [{:keys [service]} [pattern payload]]
  (when (re-matches pattern service)
    payload))

(defn find-threshold
  [thresholds re-patterns event]
  (if-let [thresholds (or (get thresholds (:service event))
                          (some (partial match-threshold event) re-patterns))]
    (if (sequential? thresholds)
      (some (partial find-specific-threshold event) thresholds)
      thresholds)))

(defn threshold-check
  "Given a list of standard or inverted thresholds, yield
   a function that will adapt an inputs state.
   The output function does not process events with no metrics"
  [thresholds]
  (let [re-patterns (filter (complement (comp string? key)) thresholds)]
    (fn [{:keys [metric tags] :as event}]
      (try
        (if-let [{:keys [warning critical invert exact add-tags]}
                 (if metric (find-threshold thresholds re-patterns event))]
          (assoc event
            :tags (clojure.set/union (set tags) (set add-tags))
            :state
            (cond
             (nil? metric)                       "unknown"
             (and exact (not= (double metric) (double exact))) "critical"
             (and exact (= (double metric) (double exact)))    "ok"
             (and critical ((if invert <= >) metric critical)) "critical"
             (and warning ((if invert <= >) metric warning))  "warning"
             :else                              "ok"))
          event)
        (catch Exception e
          (error e "threshold-check failed for " event))))))
; end

; Listen on the local interface over TCP (5555), UDP (5555), and websockets
; (5556)
(let [host "0.0.0.0"]
  (tcp-server {:host host})
  (udp-server {:host host})
  (ws-server  {:host host})
  (graphite-server  {:host host}))

; Expire old events from the index every 5 seconds.
(periodically-expire 5)

(def devnull (fn [& _]))

; TODO optimize, make better change detection
(defn delta-over-time [n & children]
  (moving-time-window n
                      #(when (> (count %) 1)
                         (let [f (first %) l (last %)
                               fval (:metric f)
                               lval (:metric l)]
                           (when (and (number? fval) (number? lval))
                             (call-rescue (assoc l
                                                 :metric (- lval fval)
                                                 :service (str (:service l) "_dt"))
                                          children))))))

(defn profiler [index]
  (splitp re-find service
          ; Aggregate rate of samples taken
          #"profiler rate" (coalesce
                               ; Total sample rate
                               (smap folds/sum
                                     (with :host nil
                                           index))

                               ; Distinct number of hosts
                               (smap folds/count
                                     (adjust [:service clojure.string/replace "rate" "hosts"]
                                             (with :host nil
                                               index))))

          ; Flatten function times across hosts, updating every 60s.
          #"profiler fn"
          (pipe - (by :service
                      (coalesce 60
                                (smap folds/sum
                                      (with {:host nil :ttl 120} -))))
                ; And index the top 10.
                (top 10 :metric
                     index
                     (with :state "expired" index)))))

(defn appender-metrics [index]
  (let [index (with :state "ok"
                index)]
        (splitp re-find service
                #"debug count|error count|info count|trace count|warn count" (where true
                                                                                    ; Sum up counters for all hosts
                                                                                    (by [:service]
                                                                                        (coalesce 4 
                                                                                                  (smap folds/sum
                                                                                                        (with {:host nil}
                                                                                                          (adjust [:service clojure.string/replace #"$" "_sum"]
                                                                                                                  ; Calcuate delta every 30 seconds
                                                                                                                  (delta-over-time 30 index))))))
                                                                                    (where (not (service "ch.qos.logback.core.Appender.all count"))
                                                                                           (by [:host :service]
                                                                                               (delta-over-time 30 index))))
                devnull)))

(def servlet-metrics-thresholds {"someWebApp org.eclipse.jetty.servlet.ServletHandler.5xx-responses count_dt" {:warning 1 :critical 5}})

(defn servlet-metrics [index]
  (let [index (smap (threshold-check servlet-metrics-thresholds)
                    index)]
    (splitp re-find service
            #"\.requests count" (coalesce (smap folds/sum
                                                (adjust [:service clojure.string/replace #"$" "_sum"]
                                                        (with :host nil
                                                          index))))
            #"xx-responses count" (by [:host :service]
                                      (delta-over-time 30
                                                       index))
            #".*p.*" index
          devnull)))

(def jvm-memory-metrics-thresholds {})

(defn jvm-memory-metrics [index]
  (splitp re-find service
          #".*heap\.used$" (scale (/ 1 1024 1024)
                                  (smap (threshold-check jvm-memory-metrics-thresholds)
                                        index))
          devnull))

(def thread-metrics-thresholds {})

(defn thread-metrics [index]
  (splitp re-find service
          #"threads.count|threads.blocked.count|threads.timed_waiting.count|threads.waiting.count" (smap (threshold-check thread-metrics-thresholds)
                                                                                                         index)
          devnull))

(def gc-metrics-thresholds {})

(defn gc-metrics [index]
  index)

(def hystrix-metrics-thresholds {"someWebApp hystrix.HystrixCommand.RemoteRequestCommand.isCircuitBreakerOpen" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countTimeout_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countFailure_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countExceptionsThrown_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countThreadPoolRejected_dt" {:critical 0.1}
                                 "someWebApp hystrix.HystrixCommand.RemoteRequestCommand.countShortCircuited_dt" {:critical 0.1}})

(defn hystrix-metrics [index]
  (splitp re-find service
          #"isCircuitBreakerOpen" (adjust (fn [{:keys [service metric] :as e}]
                                            (assoc e :metric (if (= "true" metric)
                                                               1.0
                                                               0.0)))
                                          (smap (threshold-check hystrix-metrics-thresholds)
                                                index))
          #"countSuccess" (by [:host :service]
                              (delta-over-time 30 (with :state "ok"
                                                    index)))
          #"countTimeout|countFailure|countExceptionsThrown|countThreadPoolRejected|countShortCircuited" (by [:host :service]
                                                                                                             (delta-over-time 30 (smap (threshold-check hystrix-metrics-thresholds)
                                                                                                                                       index)))
          #"latencyTotal_percentile" (by [:service] (coalesce
                                                      (smap folds/maximum
                                                            (with :host nil
                                                              index))))
          devnull))

(defn notify [index]
  (let [vo (victorops victorops-api-key victorops-routing-key)]
    (changed-state (where (state "info") (:info vo))
                   (where (state "warning") (:warning vo))
                   (where (state "critical") (:critical vo))
                   (where (state "ok") (:recovery vo)))))

(let [index (index)]
  (streams
    (where (not (or
                  (service nil)
                  (expired? event)))
           (splitp re-find service
                   #"^someWebApp profiler" (profiler index)
                   #"^someWebApp ch.qos.logback.core.Appender" (appender-metrics index)
                   #"^someWebApp org.eclipse.jetty.servlet.ServletHandler" (servlet-metrics index)
                   #"^someWebApp memory" (jvm-memory-metrics index)
                   #"^someWebApp threads" (thread-metrics index)
                   #"^someWebApp gc" (gc-metrics index)
                   #"^someWebApp hystrix.*" (hystrix-metrics index)
                   #"^riemann" devnull 
                   ;#"^fridge" (notify index)
                   ;(default {:ttl 60 :state "ok"}
                   ;  index)
                   devnull
                   ))))
